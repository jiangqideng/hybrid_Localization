C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          #include <stdlib.h>
   4          #include "lcd12864a.h"
   5          #include "CC1101.h"
   6          #include "IO_def.h"
   7          #include "server.h"
   8          #include "IMU.h"
   9          //#include  <math.h>    //Keil library  
  10          //#include  <stdio.h>   //Keil library
  11          
  12          //***************更多功率参数设置可详细参考DATACC1100英文文档中第48-49页的参数表******************
  13          //uchar PaTabel[8] = {0x04 ,0x04 ,0x04 ,0x04 ,0x04 ,0x04 ,0x04 ,0x04};  //-30dBm   功率最小
  14          //uchar PaTabel[8] = {0x60 ,0x60 ,0x60 ,0x60 ,0x60 ,0x60 ,0x60 ,0x60};  //0dBm
  15          code uchar PaTabel[8] = {0xC0 ,0xC0 ,0xC0 ,0xC0 ,0xC0 ,0xC0 ,0xC0 ,0xC0};   //10dBm     功率最大
  16          extern int j;
  17          xdata uchar TxBuf[13]={0};       // 实际上最后的混合系统只使用11个字节
  18          xdata uchar RxBuf[13]={0};
  19          int position_x=100;
  20          int position_y=100;
  21          uchar biaohao=0;                        //每组信息的标号
  22          
  23          //****************************************
  24          typedef unsigned short ushort;
  25          sbit    SCL=P2^5;                       //IIC时钟引脚定义
  26          sbit    SDA=P2^6;                       //IIC数据引脚定义
  27          //****************************************
  28          #define SlaveAddress_ADXL345   0xA6       //定义器件在IIC总线中的从地址,根据ALT  ADDRESS地址引脚不同修改      
             -                       //ALT  ADDRESS引脚接地时地址为0xA6，接电源时地址为0x3A
  29          #define SlaveAddress_HMC   0x3C   //定义器件在IIC总线中的从地址
  30          //#define       SlaveAddress_ITG   0xD0   //    注释掉了，不用ITG
  31          
  32          //****************************
  33          typedef unsigned char  BYTE;
  34          typedef unsigned short WORD;
  35          
  36          BYTE BUF_ADXL[6];                        //接收数据缓存区  
  37          BYTE BUF_HMC[6];                         //接收数据缓存区       
  38          //BYTE BUF_ITG[6];                       //接收数据缓存区    
  39          
  40          xdata int  HMC_y;                                               //y轴磁力计数据
  41          xdata int  HMC_z;                                               //z轴磁力计数据
  42          xdata uchar angle ;                                             //计算出的角度
  43          
  44          void Init_ADXL345(void);                 //初始化ADXL345
  45          void Init_HMC5883(void);                         //初始化5883
  46          //void InitITG3205();                   //初始化ITG3205
  47          
  48          void  Single_Write_ADXL345(uchar REG_Address,uchar REG_data);   //单个写入数据
  49          uchar Single_Read_ADXL345(uchar REG_Address);                   //单个读取内部寄存器数据
  50          void  Multiple_Read_ADXL345();                                  //连续的读取内部寄存器数据
  51          //------------------------------------
  52          void Delay5us();
  53          
  54          void ADXL345_Start();
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 2   

  55          void ADXL345_Stop();
  56          void ADXL345_SendACK(bit ack);
  57          bit  ADXL345_RecvACK();
  58          void ADXL345_SendByte(BYTE dat);
  59          BYTE ADXL345_RecvByte();
  60          void ADXL345_ReadPage();
  61          void ADXL345_WritePage();
  62          //-----------------------------------
  63          
  64          /*******************************/
  65          void  Single_Write_HMC5883(uchar REG_Address,uchar REG_data);   //单个写入数据
  66          uchar Single_Read_HMC5883(uchar REG_Address);                   //单个读取内部寄存器数据
  67          void  Multiple_Read_HMC5883();                                  //连续的读取内部寄存器数据                                      
  68          /*******************************/
  69          void HMC5883_Start();
  70          void HMC5883_Stop();
  71          void HMC5883_SendACK(bit ack);
  72          bit  HMC5883_RecvACK();
  73          void HMC5883_SendByte(BYTE dat);
  74          BYTE HMC5883_RecvByte();
  75          void HMC5883_ReadPage();
  76          void HMC5883_WritePage();       
  77          
  78          //void  Single_WriteITG3205(uchar REG_Address,uchar REG_data);   //单个写入数据
  79          //uchar Single_ReadITG3205(uchar REG_Address);                   //单个读取内部寄存器数据
  80          //void ITG3205_Start();
  81          //void ITG3205_Stop();
  82          //void ITG3205_SendACK(bit ack);
  83          //bit  ITG3205_RecvACK();
  84          //void ITG3205_SendByte(BYTE dat);
  85          //BYTE ITG3205_RecvByte();
  86          //void ITG3205_ReadPage();
  87          //void ITG3205_WritePage();
  88          //****************************************                      
  89          
  90          /**************************************
  91          延时5微秒(STC90C52RC@12M)
  92          不同的工作环境,需要调整此函数，注意时钟过快时需要修改
  93          当改用1T的MCU时,请调整此延时函数
  94          **************************************/
  95          void Delay5us()
  96          {
  97   1          _nop_();_nop_();_nop_();_nop_();
  98   1          _nop_();_nop_();_nop_();_nop_();
  99   1              _nop_();_nop_();_nop_();_nop_();
 100   1      }
 101          
 102          
 103          /**************************************
 104          起始信号
 105          **************************************/
 106          void ADXL345_Start()
 107          {
 108   1          SDA = 1;                    //拉高数据线
 109   1          SCL = 1;                    //拉高时钟线
 110   1          Delay5us();                 //延时
 111   1          SDA = 0;                    //产生下降沿
 112   1          Delay5us();                 //延时
 113   1          SCL = 0;                    //拉低时钟线
 114   1      }
 115          
 116          /**************************************
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 3   

 117          停止信号
 118          **************************************/
 119          void ADXL345_Stop()
 120          {
 121   1          SDA = 0;                    //拉低数据线
 122   1          SCL = 1;                    //拉高时钟线
 123   1          Delay5us();                 //延时
 124   1          SDA = 1;                    //产生上升沿
 125   1          Delay5us();                 //延时
 126   1      }
 127          
 128          /**************************************
 129          发送应答信号
 130          入口参数:ack (0:ACK 1:NAK)
 131          **************************************/
 132          void ADXL345_SendACK(bit ack)
 133          {
 134   1          SDA = ack;                  //写应答信号
 135   1          SCL = 1;                    //拉高时钟线
 136   1          Delay5us();                 //延时
 137   1          SCL = 0;                    //拉低时钟线
 138   1          Delay5us();                 //延时
 139   1      }
 140          
 141          /**************************************
 142          接收应答信号
 143          **************************************/
 144          bit ADXL345_RecvACK()
 145          {
 146   1          SCL = 1;                    //拉高时钟线
 147   1          Delay5us();                 //延时
 148   1          CY = SDA;                   //读应答信号
 149   1          SCL = 0;                    //拉低时钟线
 150   1          Delay5us();                 //延时
 151   1      
 152   1          return CY;
 153   1      }
 154          
 155          /**************************************
 156          向IIC总线发送一个字节数据
 157          **************************************/
 158          void ADXL345_SendByte(BYTE dat)
 159          {
 160   1          BYTE i;
 161   1      
 162   1          for (i=0; i<8; i++)         //8位计数器
 163   1          {
 164   2              dat <<= 1;              //移出数据的最高位
 165   2              SDA = CY;               //送数据口
 166   2              SCL = 1;                //拉高时钟线
 167   2              Delay5us();             //延时
 168   2              SCL = 0;                //拉低时钟线
 169   2              Delay5us();             //延时
 170   2          }
 171   1          ADXL345_RecvACK();
 172   1      }
 173          
 174          /**************************************
 175          从IIC总线接收一个字节数据
 176          **************************************/
 177          BYTE ADXL345_RecvByte()
 178          {
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 4   

 179   1          BYTE i;
 180   1          BYTE dat = 0;
 181   1      
 182   1          SDA = 1;                    //使能内部上拉,准备读取数据,
 183   1          for (i=0; i<8; i++)         //8位计数器
 184   1          {
 185   2              dat <<= 1;
 186   2              SCL = 1;                //拉高时钟线
 187   2              Delay5us();             //延时
 188   2              dat |= SDA;             //读数据               
 189   2              SCL = 0;                //拉低时钟线
 190   2              Delay5us();             //延时
 191   2          }
 192   1          return dat;
 193   1      }
 194          
 195          //******单字节写入*******************************************
 196          
 197          void Single_Write_ADXL345(uchar REG_Address,uchar REG_data)
 198          {
 199   1          ADXL345_Start();                  //起始信号
 200   1          ADXL345_SendByte(SlaveAddress_ADXL345);   //发送设备地址+写信号
 201   1          ADXL345_SendByte(REG_Address);    //内部寄存器地址，请参考中文pdf22页 
 202   1          ADXL345_SendByte(REG_data);       //内部寄存器数据，请参考中文pdf22页 
 203   1          ADXL345_Stop();                   //发送停止信号
 204   1      }
 205          
 206          //********单字节读取*****************************************
 207          uchar Single_Read_ADXL345(uchar REG_Address)
 208          {  uchar REG_data;
 209   1          ADXL345_Start();                          //起始信号
 210   1          ADXL345_SendByte(SlaveAddress_ADXL345);           //发送设备地址+写信号
 211   1          ADXL345_SendByte(REG_Address);                   //发送存储单元地址，从0开始        
 212   1          ADXL345_Start();                          //起始信号
 213   1          ADXL345_SendByte(SlaveAddress_ADXL345+1);         //发送设备地址+读信号
 214   1          REG_data=ADXL345_RecvByte();              //读出寄存器数据
 215   1              ADXL345_SendACK(1);   
 216   1              ADXL345_Stop();                           //停止信号
 217   1          return REG_data; 
 218   1      }
 219          //*********************************************************
 220          //
 221          //连续读出ADXL345内部加速度数据，地址范围0x32~0x37
 222          //
 223          //*********************************************************
 224          void Multiple_Read_ADXL345(void)
 225          {   uchar i;
 226   1          ADXL345_Start();                          //起始信号
 227   1          ADXL345_SendByte(SlaveAddress_ADXL345);           //发送设备地址+写信号
 228   1          ADXL345_SendByte(0x32);                   //发送存储单元地址，从0x32开始    
 229   1          ADXL345_Start();                          //起始信号
 230   1          ADXL345_SendByte(SlaveAddress_ADXL345+1);         //发送设备地址+读信号
 231   1               for (i=0; i<6; i++)                      //连续读取6个地址数据，存储中BUF
 232   1          {
 233   2              BUF_ADXL[i] = ADXL345_RecvByte();          //BUF[0]存储0x32地址中的数据
 234   2              if (i == 5)
 235   2              {
 236   3                 ADXL345_SendACK(1);                //最后一个数据需要回NOACK
 237   3              }
 238   2              else
 239   2              {
 240   3                ADXL345_SendACK(0);                //回应ACK
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 5   

 241   3             }
 242   2         }
 243   1          ADXL345_Stop();                          //停止信号
 244   1      //    delay_ms(5);
 245   1      }
 246          
 247          
 248          //*****************************************************************
 249          
 250          //初始化ADXL345，根据需要请参考pdf进行修改************************
 251          void Init_ADXL345()
 252          {
 253   1         Single_Write_ADXL345(0x31,0x0B);   //测量范围,正负16g，13位模式
 254   1         Single_Write_ADXL345(0x2C,0x0C);   //速率设定为200Hz 参考pdf13页
 255   1         Single_Write_ADXL345(0x2D,0x08);   //选择电源模式   参考pdf24页
 256   1         Single_Write_ADXL345(0x2E,0x80);   //使能 DATA_READY 中断
 257   1         Single_Write_ADXL345(0x1E,0x00);   //X 偏移量 根据测试传感器的状态写入pdf29页
 258   1         Single_Write_ADXL345(0x1F,0x00);   //Y 偏移量 根据测试传感器的状态写入pdf29页
 259   1         Single_Write_ADXL345(0x20,0x05);   //Z 偏移量 根据测试传感器的状态写入pdf29页
 260   1      }
 261          //***********************************************************************
 262          
 263          /**************************************
 264          起始信号
 265          **************************************/
 266          void HMC5883_Start()
 267          {
 268   1          SDA = 1;                    //拉高数据线
 269   1          SCL = 1;                    //拉高时钟线
 270   1          Delay5us();                 //延时
 271   1          SDA = 0;                    //产生下降沿
 272   1          Delay5us();                 //延时
 273   1          SCL = 0;                    //拉低时钟线
 274   1      }
 275          
 276          /**************************************
 277          停止信号
 278          **************************************/
 279          void HMC5883_Stop()
 280          {
 281   1          SDA = 0;                    //拉低数据线
 282   1          SCL = 1;                    //拉高时钟线
 283   1          Delay5us();                 //延时
 284   1          SDA = 1;                    //产生上升沿
 285   1          Delay5us();                 //延时
 286   1      }
 287          
 288          /**************************************
 289          发送应答信号
 290          入口参数:ack (0:ACK 1:NAK)
 291          **************************************/
 292          void HMC5883_SendACK(bit ack)
 293          {
 294   1          SDA = ack;                  //写应答信号
 295   1          SCL = 1;                    //拉高时钟线
 296   1          Delay5us();                 //延时
 297   1          SCL = 0;                    //拉低时钟线
 298   1          Delay5us();                 //延时
 299   1      }
 300          
 301          /**************************************
 302          接收应答信号
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 6   

 303          **************************************/
 304          bit HMC5883_RecvACK()
 305          {
 306   1          SCL = 1;                    //拉高时钟线
 307   1          Delay5us();                 //延时
 308   1          CY = SDA;                   //读应答信号
 309   1          SCL = 0;                    //拉低时钟线
 310   1          Delay5us();                 //延时
 311   1      
 312   1          return CY;
 313   1      }
 314          
 315          /**************************************
 316          向IIC总线发送一个字节数据
 317          **************************************/
 318          void HMC5883_SendByte(BYTE dat)
 319          {
 320   1          BYTE i;
 321   1      
 322   1          for (i=0; i<8; i++)         //8位计数器
 323   1          {
 324   2              dat <<= 1;              //移出数据的最高位
 325   2              SDA = CY;               //送数据口
 326   2              SCL = 1;                //拉高时钟线
 327   2              Delay5us();             //延时
 328   2              SCL = 0;                //拉低时钟线
 329   2              Delay5us();             //延时
 330   2          }
 331   1          HMC5883_RecvACK();
 332   1      }
 333          
 334          /**************************************
 335          从IIC总线接收一个字节数据
 336          **************************************/
 337          BYTE HMC5883_RecvByte()
 338          {
 339   1          BYTE i;
 340   1          BYTE dat = 0;
 341   1      
 342   1          SDA = 1;                    //使能内部上拉,准备读取数据,
 343   1          for (i=0; i<8; i++)         //8位计数器
 344   1          {
 345   2              dat <<= 1;
 346   2              SCL = 1;                //拉高时钟线
 347   2              Delay5us();             //延时
 348   2              dat |= SDA;             //读数据               
 349   2              SCL = 0;                //拉低时钟线
 350   2              Delay5us();             //延时
 351   2          }
 352   1          return dat;
 353   1      }
 354          
 355          //***************************************************
 356          
 357          void Single_Write_HMC5883(uchar REG_Address,uchar REG_data)
 358          {
 359   1          HMC5883_Start();                  //起始信号
 360   1          HMC5883_SendByte(SlaveAddress_HMC);   //发送设备地址+写信号
 361   1          HMC5883_SendByte(REG_Address);    //内部寄存器地址，请参考中文pdf 
 362   1          HMC5883_SendByte(REG_data);       //内部寄存器数据，请参考中文pdf
 363   1          HMC5883_Stop();                   //发送停止信号
 364   1      }
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 7   

 365          
 366          //********单字节读取内部寄存器*************************
 367          uchar Single_Read_HMC5883(uchar REG_Address)
 368          {  uchar REG_data;
 369   1          HMC5883_Start();                          //起始信号
 370   1          HMC5883_SendByte(SlaveAddress_HMC);           //发送设备地址+写信号
 371   1          HMC5883_SendByte(REG_Address);                   //发送存储单元地址，从0开始        
 372   1          HMC5883_Start();                          //起始信号
 373   1          HMC5883_SendByte(SlaveAddress_HMC+1);         //发送设备地址+读信号
 374   1          REG_data=HMC5883_RecvByte();              //读出寄存器数据
 375   1              HMC5883_SendACK(1);   
 376   1              HMC5883_Stop();                           //停止信号
 377   1          return REG_data; 
 378   1      }
 379          //******************************************************
 380          //
 381          //连续读出HMC5883内部角度数据，地址范围0x3~0x5
 382          //
 383          //******************************************************
 384          void Multiple_Read_HMC5883(void)
 385          {   uchar i;
 386   1          HMC5883_Start();                          //起始信号
 387   1          HMC5883_SendByte(SlaveAddress_HMC);           //发送设备地址+写信号
 388   1          HMC5883_SendByte(0x03);                   //发送存储单元地址，从0x3开始     
 389   1          HMC5883_Start();                          //起始信号
 390   1          HMC5883_SendByte(SlaveAddress_HMC+1);         //发送设备地址+读信号
 391   1               for (i=0; i<6; i++)                      //连续读取6个地址数据，存储中BUF
 392   1          {
 393   2              BUF_HMC[i] = HMC5883_RecvByte();          //BUF[0]存储数据
 394   2              if (i == 5)
 395   2              {
 396   3                 HMC5883_SendACK(1);                //最后一个数据需要回NOACK
 397   3              }
 398   2              else
 399   2              {
 400   3                HMC5883_SendACK(0);                //回应ACK
 401   3             }
 402   2         }
 403   1          HMC5883_Stop();                          //停止信号
 404   1      }
 405          
 406          //初始化HMC5883，根据需要请参考pdf进行修改****
 407          void Init_HMC5883()
 408          {
 409   1           Single_Write_HMC5883(0x02,0x00);  //
 410   1      }
 411          
 412          //**************************************/
 413          
 414          
 415          
 416          
 417          //**************************************/
 418          /*void ITG3205_Start()
 419          {
 420              SDA = 1;                    //拉高数据线
 421              SCL = 1;                    //拉高时钟线
 422              Delay5us();                 //延时
 423              SDA = 0;                    //产生下降沿
 424              Delay5us();                 //延时
 425              SCL = 0;                    //拉低时钟线
 426          }
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 8   

 427          
 428          //**************************************
 429          //停止信号
 430          //**************************************
 431          void ITG3205_Stop()
 432          {
 433              SDA = 0;                    //拉低数据线
 434              SCL = 1;                    //拉高时钟线
 435              Delay5us();                 //延时
 436              SDA = 1;                    //产生上升沿
 437              Delay5us();                 //延时
 438          }
 439          
 440          //**************************************
 441          //发送应答信号
 442          //入口参数:ack (0:ACK 1:NAK)
 443          //*************************************
 444          void ITG3205_SendACK(bit ack)
 445          {
 446              SDA = ack;                  //写应答信号
 447              SCL = 1;                    //拉高时钟线
 448              Delay5us();                 //延时
 449              SCL = 0;                    //拉低时钟线
 450              Delay5us();                 //延时
 451          }
 452          
 453          //**************************************
 454          //接收应答信号
 455          //**************************************
 456          bit ITG3205_RecvACK()
 457          {
 458              SCL = 1;                    //拉高时钟线
 459              Delay5us();                 //延时
 460              CY = SDA;                   //读应答信号
 461              SCL = 0;                    //拉低时钟线
 462              Delay5us();                 //延时
 463          
 464              return CY;
 465          }
 466          
 467          //**************************************
 468          //向IIC总线发送一个字节数据
 469          //**************************************
 470          void ITG3205_SendByte(BYTE dat)
 471          {
 472              BYTE i;
 473          
 474              for (i=0; i<8; i++)         //8位计数器
 475              {
 476                  dat <<= 1;              //移出数据的最高位
 477                  SDA = CY;               //送数据口
 478                  SCL = 1;                //拉高时钟线
 479                  Delay5us();             //延时
 480                  SCL = 0;                //拉低时钟线
 481                  Delay5us();             //延时
 482              }
 483              ITG3205_RecvACK();
 484          }
 485          
 486          //**************************************
 487          //从IIC总线接收一个字节数据
 488          //**************************************
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 9   

 489          BYTE ITG3205_RecvByte()
 490          {
 491              BYTE i;
 492              BYTE dat = 0;
 493          
 494              SDA = 1;                    //使能内部上拉,准备读取数据,
 495              for (i=0; i<8; i++)         //8位计数器
 496              {
 497                  dat <<= 1;
 498                  SCL = 1;                //拉高时钟线
 499                  Delay5us();             //延时
 500                  dat |= SDA;             //读数据               
 501                  SCL = 0;                //拉低时钟线
 502                  Delay5us();             //延时
 503              }
 504              return dat;
 505          }
 506          
 507          //单字节写入*******************************************
 508          
 509          void Single_WriteITG3205(uchar REG_Address,uchar REG_data)
 510          {
 511              ITG3205_Start();                  //起始信号
 512              ITG3205_SendByte(SlaveAddress_ITG);   //发送设备地址+写信号
 513              ITG3205_SendByte(REG_Address);    //内部寄存器地址，
 514              ITG3205_SendByte(REG_data);       //内部寄存器数据，
 515              ITG3205_Stop();                   //发送停止信号
 516          }
 517          
 518          //单字节读取*****************************************
 519          uchar Single_ReadITG3205(uchar REG_Address)
 520          {  uchar REG_data;
 521              ITG3205_Start();                          //起始信号
 522              ITG3205_SendByte(SlaveAddress_ITG);           //发送设备地址+写信号
 523              ITG3205_SendByte(REG_Address);            //发送存储单元地址，从0开始       
 524              ITG3205_Start();                          //起始信号
 525              ITG3205_SendByte(SlaveAddress_ITG+1);         //发送设备地址+读信号
 526              REG_data=ITG3205_RecvByte();              //读出寄存器数据
 527                  ITG3205_SendACK(1);   
 528                  ITG3205_Stop();                           //停止信号
 529              return REG_data; 
 530          }
 531          
 532          //初始化ITG3205，根据需要请参考pdf进行修改************************
 533          void InitITG3205()
 534          {
 535             Single_WriteITG3205(PWR_M, 0x80);   //
 536             Single_WriteITG3205(SMPL, 0x07);    //
 537             Single_WriteITG3205(DLPF, 0x1E);    //±2000°
 538             Single_WriteITG3205(INT_C, 0x00 );  //
 539             Single_WriteITG3205(PWR_M, 0x00);   //
 540          }                  */
 541          //***********************************************************************
 542          
 543          
 544          //*********************************************************
 545          
 546          //**************************************
 547          //在1602上显示10位数据
 548          
 549          //**************************************
 550          //显示温度
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 10  

 551          //**************************************
 552          //void display_temp()
 553          //{ 
 554          //      Temp_h=Single_ReadI2C(TEMP_OUT_H); //读取温度
 555          //      Temp_l=Single_ReadI2C(TEMP_OUT_L); //读取温度
 556          //      Temperature=Temp_h<<8|Temp_l;     //合成温度
 557          //      Temperature = 35+ ((double) (Temperature + 13200)) / 280; // 计算出温度
 558          //      lcd_printf(dis,Temperature);     //转换数据显示
 559          //      DisplayListChar(11,1,dis,4);     //启始列，行，显示数组，显示位数
 560          //}
 561                     
 562          
 563          //步伐检测的程序从matalb那边移植过来，去那边看注释//
 564           uchar IMU_i=0;
 565           uchar IMU_j=0;
 566           uchar TH1_now,TL1_now;
 567          
 568          int u_u_gate=8000;
 569          int u_d_gate=450;
 570          int d_u_gate=-450;
 571          xdata int d_d_gate=-8000;
 572          xdata int gate_init=0;
 573          xdata int path_sum=0;             //matlab里只有变量path
 574          xdata uchar path_num=0; 
 575          xdata int samepath=20;
 576          xdata uchar path_f=20;
 577          xdata int path_d=0;
 578          xdata int path_max_old=0;
 579          xdata int path_min_old=0;
 580          xdata uchar pre_match=0;
 581          xdata int abnormal=80;
 582          xdata int buf_z[50]={0};                //matlab里这个变量叫buf
 583          xdata int buf_sum[40]={0};
 584          xdata int max_y=0;
 585          xdata int min_y=0;
 586          xdata int accel_y=0;
 587          xdata int accel_x=0;
 588          int path_distance_sum=0;
 589          xdata uchar path_distance=0;
 590          xdata uchar path_d_old=0;
 591          xdata uchar test=0;
 592          xdata int  maxmin_sum=0;
 593          xdata int  path_d_sum=0;
 594          
 595          void path_test()
 596          {       uchar disp_result[4]=0;
 597   1              uchar num_u=0;
 598   1              uchar num_d=0;
 599   1              int path_max=0;
 600   1              int path_min=0;
 601   1              int maxmin=0;
 602   1              uchar path_false=0;
 603   1              uchar j=0;
 604   1              if(TF1==1)      {IMU_j++;TH1=0x00;TL1=0x00;TF1=0;}      
 605   1              Multiple_Read_ADXL345();                                                 //这个语句运行0.57ms
 606   1              TH1_now=TH1;TL1_now=TL1;                                                //记录当前数据与上一个数据间的时间差
 607   1              TH1=0x00;
 608   1              TL1=0x00;
 609   1              TF1=0;
 610   1      
 611   1      /*        BUF_ITG[0]= Single_ReadITG3205(GX_L);
 612   1            BUF_ITG[1]= Single_ReadITG3205(GX_H);     //x
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 11  

 613   1            BUF_ITG[2]= Single_ReadITG3205(GY_L);
 614   1            BUF_ITG[3]= Single_ReadITG3205(GY_H);     //y
 615   1            BUF_ITG[4]= Single_ReadITG3205(GZ_L);
 616   1            BUF_ITG[5]= Single_ReadITG3205(GZ_H);     //z             */
 617   1      
 618   1                Multiple_Read_HMC5883();      //连续读出数据，存储在BUF_HMC中    //这个语句运行0.56ms
 619   1      
 620   1                HMC_z=BUF_HMC[2] << 8 | BUF_HMC[3];   
 621   1                HMC_y=BUF_HMC[4] << 8 | BUF_HMC[5];
 622   1                      if(HMC_z>=32768)
 623   1                      {       HMC_z=HMC_z-65536;                      
 624   2                      }
 625   1                      if(HMC_y>=32768)
 626   1                      {       HMC_y=HMC_y-65536;                      
 627   2                      }
 628   1                HMC_z=HMC_z+167;
 629   1                HMC_y=HMC_y+397;      
 630   1      //        angle= atan2((double)HMC_y,(double)HMC_z) * (180 / 3.14159265) + 180; // angle in degrees      
 631   1      /////////////////////////判断方向////////////////////////////////////////////////////
 632   1               if (HMC_z>150 && HMC_y<243 && HMC_y>-243)      //222
 633   1                      angle=2;
 634   1                      else if (HMC_z<-150 && HMC_y<243 && HMC_y>-243)     //-222
 635   1                              angle =4;
 636   1                                      else if (HMC_y>0)                       //245
 637   1                                              angle=1;
 638   1                                              else 
 639   1                                                      angle=3;
 640   1      
 641   1      
 642   1      /*      if (position_x>=11 && position_x<=67)            //此时的方向只可能为1或3
 643   1                      if (HMC_y>0)
 644   1                              angle=1;
 645   1                      else 
 646   1                              angle=3;
 647   1              if (position_y>=11 && position_y<=46)            //此时的方向只可能为2或4
 648   1                      if(HMC_z>0)
 649   1                              angle=2;
 650   1                      else
 651   1                              angle=4;                  */
 652   1      //        writedigital(angle,6,65);
 653   1      /////////////////////////////////////////////////////////////////////////////////////////////
 654   1      
 655   1              TxBuf[1]=TH1_now;
 656   1              TxBuf[2]=TL1_now;
 657   1      //      TxBuf[3]=BUF_ITG[5];
 658   1      //      TxBuf[4]=BUF_ITG[4];
 659   1      //      TxBuf[3]=BUF_ADXL[1];
 660   1      //      TxBuf[4]=BUF_ADXL[0];
 661   1      //      TxBuf[1]=BUF_ADXL[5];
 662   1      //      TxBuf[2]=BUF_ADXL[4];
 663   1              TxBuf[3]=BUF_ADXL[1];
 664   1              TxBuf[4]=BUF_ADXL[0];
 665   1              TxBuf[5]=0x99; 
 666   1              TxBuf[6]=IMU_j;
 667   1              IMU_j=0;
 668   1              
 669   1      //      halRfSendPacket(TxBuf,7);                       //这里运行2.76ms，没多发送一个字节，多耗时0.12ms
 670   1      //      my_delay(1843);
 671   1      
 672   1      //*********************更新buf_z*******************************************      下面的这段步伐检测耗费大约0.5
             -ms
 673   1      
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 12  

 674   1              for(IMU_i=0;IMU_i<49;IMU_i++)
 675   1              {   buf_z[IMU_i]=buf_z[IMU_i+1];
 676   2              }
 677   1      
 678   1              buf_z[49]=(BUF_ADXL[1]<<8)+BUF_ADXL[0];
 679   1              if(buf_z[49]>=32768)
 680   1                      {       buf_z[49]=buf_z[49]-65536;                      
 681   2                      }
 682   1              buf_z[49]=buf_z[49]*39/10-1024;                  
 683   1              for (IMU_i=0;IMU_i<40;IMU_i++)                  //每次计算之前将buf_sum清零，matlab的计算和这里不一样
 684   1              {               buf_sum[IMU_i]=0;
 685   2              }
 686   1              for (IMU_i=0;IMU_i<40;IMU_i++)
 687   1              {       for (j=0;j<11;j++) 
 688   2                              { buf_sum[IMU_i]=buf_sum[IMU_i]+buf_z[IMU_i+j];
 689   3                              }       
 690   2              }
 691   1      
 692   1              accel_y=(BUF_ADXL[5]<<8)+BUF_ADXL[4];
 693   1              if(accel_y>=32768)
 694   1                      {       accel_y=accel_y-65536;                  
 695   2                      }
 696   1              accel_y=accel_y*39/10;
 697   1              
 698   1              accel_x=(BUF_ADXL[5]<<8)+BUF_ADXL[4];
 699   1              if(accel_x>=32768)
 700   1                      {       accel_x=accel_x-65536;                  
 701   2                      }
 702   1              accel_x=accel_x*39/10;                  
 703   1      
 704   1               samepath=samepath+1;
 705   1               path_d=path_d+1;
 706   1               gate_init=gate_init+1;
 707   1               abnormal=abnormal+1;
 708   1               if (abnormal>250)
 709   1                      abnormal=80;
 710   1               if (gate_init>120)
 711   1               {      u_d_gate=450;
 712   2                      d_u_gate=-450;
 713   2                      u_u_gate=9000;
 714   2                      d_d_gate=-9000;
 715   2                      path_max_old=0;
 716   2                      path_min_old=0;
 717   2               }      
 718   1      
 719   1               if (accel_y>max_y)
 720   1                      { max_y=accel_y;}
 721   1               if (accel_y<min_y)
 722   1                      { min_y=accel_y;}
 723   1               if (buf_z[49]>10000 || buf_z[49]<-10000        || accel_x>1000 || accel_x<-1000 || accel_y>1000 || accel_y<-130
             -0 ) 
 724   1                      {abnormal=0;}
 725   1      
 726   1      
 727   1               for (IMU_i=0;IMU_i<20;IMU_i++)
 728   1               {      if(buf_sum[IMU_i]>=u_d_gate)
 729   2                      {       num_u=num_u+1;     }
 730   2      //              if (buf_sum[IMU_i]>=u_u_gate && abnormal>=50)
 731   2      //              {    abnormal=40;       }
 732   2                      if (buf_sum[IMU_i]>path_max)
 733   2                      {        path_max=buf_sum[IMU_i];}
 734   2      
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 13  

 735   2               }
 736   1               for (IMU_i=20;IMU_i<40;IMU_i++)
 737   1               {      if(buf_sum[IMU_i]<=d_u_gate)
 738   2                      {       num_d=num_d+1;     }
 739   2      //              if (buf_sum[IMU_i]<=d_d_gate && abnormal>=50)
 740   2      //              {    abnormal=40;       }
 741   2                      if (buf_sum[IMU_i]<path_min)
 742   2                      {        path_min=buf_sum[IMU_i];}
 743   2      
 744   2               }
 745   1                                                                                                 //从读取信息完毕然后发送之后，运行到这里花费5.57ms
 746   1               if (num_u>3 && num_d>2)
 747   1               {              
 748   2                              if (samepath>=5)
 749   2                              {       if (path_max_old-path_min_old<3000)
 750   3                                      {       path_f=20;       }
 751   3                                      else
 752   3                                      {       path_f=20;       }
 753   3      
 754   3                                      if (abnormal>=50)
 755   3                                      {       pre_match=1; }
 756   3      
 757   3                                      path_max_old=0;
 758   3                                      path_min_old=0;
 759   3                                      
 760   3                              }
 761   2                       samepath=0;
 762   2                       if (path_max>path_max_old)
 763   2                              {path_max_old=path_max;}
 764   2                       if (path_min<path_min_old)
 765   2                              {path_min_old=path_min;}
 766   2      
 767   2                       if (path_max>u_u_gate || path_min<d_d_gate)
 768   2                              {path_false=1;}
 769   2      
 770   2                       gate_init=0;
 771   2      
 772   2               }
 773   1      
 774   1               if (samepath==6)
 775   1               {//    if (max_y>=50 && max_y-min_y>=100)
 776   2                      {
 777   3                              if (pre_match==1 && path_d>path_f)
 778   3                              {
 779   4                                      path_num++;                
 780   4                                      path_sum++;
 781   4                                      pre_match=0;
 782   4                                      maxmin=max_y-min_y;
 783   4      
 784   4          if (maxmin<=250)                 
 785   4              path_distance=54;
 786   4              else if (maxmin<300)
 787   4              path_distance=87;
 788   4          else if (maxmin<350)
 789   4              path_distance=92;
 790   4          else if (maxmin<400)
 791   4              path_distance=96;
 792   4          else if (maxmin<450)
 793   4              path_distance=100;
 794   4          else if (maxmin<500)
 795   4              path_distance=107;
 796   4          else if (maxmin<550)
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 14  

 797   4              path_distance=112;
 798   4          else if (maxmin<600)
 799   4              path_distance=114;
 800   4          else if (maxmin<650)
 801   4              path_distance=116;
 802   4          else if (maxmin<700)
 803   4              path_distance=118;
 804   4          else if (maxmin<800)
 805   4              path_distance=120;
 806   4          else if (maxmin<9000)
 807   4              path_distance=122;
 808   4          else if (maxmin>900)
 809   4              path_distance=125;
 810   4      
 811   4                         if (path_distance_sum>=10000)
 812   4                                path_distance_sum=0;
 813   4      
 814   4                         path_distance_sum=path_distance_sum+path_distance;
 815   4                         if (angle==1) 
 816   4                              position_x=position_x-(path_distance-path_false*path_d_old);
 817   4                         if (angle==2)
 818   4                              position_y=position_y+(path_distance-path_false*path_d_old);
 819   4                         if (angle==3)
 820   4                              position_x=position_x+(path_distance-path_false*path_d_old);
 821   4                         if (angle==4)
 822   4                              position_y=position_y-(path_distance-path_false*path_d_old);
 823   4      
 824   4                         if (path_false==1)
 825   4                                {path_distance_sum=path_distance_sum-path_d_old;
 826   5                                 path_sum=path_sum-1;
 827   5                                 path_false=0;
 828   5                                }
 829   4                              path_d_old=path_distance;
 830   4                              max_y=0;
 831   4                              min_y=0;
 832   4      
 833   4              
 834   4      //                              Dispchar(path_num,5,90);
 835   4      //                              Dispchar(path_sum,3,90);
 836   4      //                              Dispchar(path_distance,3,120);
 837   4      //                              Dispchar(path_distance_sum/100,1,120);
 838   4      //////////////////////////////利用地图与方向信息校准//////////////////////////////////////////////////////
             -//////
 839   4                                      if (position_x>400 && position_x<7400 && position_y>400 && position_y<5300)              //如果出现在了不允许出现
             -的位置，这时候来消除误差
 840   4                                              {               
 841   5                                                      if (angle==1 || angle==3)
 842   5                                                              if (position_y<2800)
 843   5                                                                      position_y=100;
 844   5                                                              else
 845   5                                                                      position_y=5600;
 846   5                                                      else 
 847   5                                                              if (position_x<3800)
 848   5                                                                      position_x=100;
 849   5                                                              else 
 850   5                                                                      position_x=7700;
 851   5                                              }
 852   4                                       if (position_x>7700)
 853   4                                              position_x=7700;
 854   4                                       if (position_x<100)
 855   4                                              position_x=100;
 856   4                                       if (position_y>5600)
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 15  

 857   4                                              position_y=5600;
 858   4                                       if (position_y<100)
 859   4                                              position_y=100;
 860   4      //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -///////////
 861   4      
 862   4                                                      Dispchar2(position_x/100,4,50);
 863   4                                                      writedigital(19,4,34);    // 小数点
 864   4                                                      Dispchar2(position_x%100,4,31);
 865   4                                                      Dispchar2(position_y/100,2,50);
 866   4                                                      writedigital(19,2,34);    // 小数点
 867   4                                                      Dispchar2(position_y%100,2,31);                           
 868   4      
 869   4                                                      Dispchar2(path_sum%100,6,54);
 870   4      
 871   4                                                      Dispchar2(path_distance/100,6,36);
 872   4                                                      writedigital(19,6,20);    // 小数点
 873   4                                                      Dispchar2(path_distance%100,6,17);      
 874   4                                                      
 875   4      
 876   4                              }
 877   3                          path_d=0;
 878   3              
 879   3                              d_d_gate=path_min_old*4;
 880   3                              if (path_min_old/5<-450)
 881   3                                      d_u_gate=path_min_old/5;
 882   3                              else 
 883   3                                      d_u_gate=-450;
 884   3              
 885   3                              u_u_gate=path_max_old*3;
 886   3                              if (path_max_old/3>450)
 887   3                                      u_d_gate=path_max_old/3;
 888   3                              else
 889   3                                      u_d_gate=450;
 890   3                       }      
 891   2      //               else
 892   2      //               {test++;Dispchar(test,5,20);}
 893   2               }                                      
 894   1      
 895   1      //从上面的窗口赋值完毕后，运行到这里，如果没有进入if，基本不花时间，如果进入了if
 896   1      //      Dispchar(BUF_ADXL[0],3,90);              
 897   1      }
 898          void my_send_data()
 899          {                                               uchar i=0;
 900   1                                                      TxBuf[0]=0x00;
 901   1                                                      TxBuf[1]=0xFF;
 902   1                                                      TxBuf[2]=0x01;
 903   1                                                      TxBuf[3]=0xFF;
 904   1                                                      TxBuf[4]=0x00;
 905   1                                                      TxBuf[5]=biaohao;
 906   1                                                      TxBuf[6]=angle;
 907   1      //                                              TxBuf[7]=position_x/100;
 908   1      //                                              TxBuf[8]=position_x%100;
 909   1                                                      TxBuf[7]=path_distance_sum/100;
 910   1                                                      TxBuf[8]=path_distance_sum%100;
 911   1                                                      TxBuf[9]=position_y/100;
 912   1                                                      TxBuf[10]=position_y%100;
 913   1      
 914   1      
 915   1                                                      for (i=0;i<1;i++)
 916   1                                                      {       if (KEY2==0)                              //用来测惯导性能，到达某点都按下KEY2，惯导暂停工作，同时发送信息给主机，
 917   2                                                                      {       halRfSendPacket(TxBuf,11); delay_ms(2000);}
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 16  

 918   2      
 919   2      //                                                      my_delay(120);          //为了保持采样频率100Hz
 920   2                                                              if (KEY2!=0)                              //这样的话如果按着按键，惯导就不进行工作
 921   2                                                              path_test();
 922   2                                                      }       
 923   1                                                        
 924   1      }
 925          
 926          void main()
 927          {               uchar i_signal=0;
 928   1                      uchar ss=1;
 929   1                      uchar leng=10;
 930   1                      uchar tt=0;
 931   1      
 932   1          
 933   1              BELL =1;                 //不响铃
 934   1              LED1=0;                  //开灯
 935   1              LED2=0;
 936   1      //      UART_init();
 937   1      //    back_lcd=0;         //液晶背光开
 938   1          lcd_init();
 939   1      //      delay_ms(500);
 940   1      //      delay1();
 941   1      //    delay1();
 942   1      //    delay1();
 943   1          disdate_a(0x00,0x00);                                 
 944   1              delay_ms(500);
 945   1      //      delay1();
 946   1      //    delay1();
 947   1      //    delay1();
 948   1      //  entermenu();              /*-----开机显示  天津大学欢迎您！ -----*/
 949   1      //      delay1();
 950   1      //    delay1();
 951   1      //    delay1();
 952   1      //    disdate_a(0x00,0x00);
 953   1         back_lcd=1;                  //液晶背光关
 954   1      
 955   1              CpuInit();
 956   1              POWER_UP_RESET_CC1101();
 957   1              halRfWriteRfSettings();
 958   1              halSpiWriteBurstReg(CC1101_PATABLE, PaTabel, 8);        // CC1101_PATABLE=0011 1111
 959   1              LED1=1;
 960   1              //TxBuf[0] = 8 ;
 961   1      //      TxBuf[1] = 1 ;
 962   1      //      TxBuf[2] = 1 ;
 963   1      //      halRfSendPacket(TxBuf,8);       // Transmit Tx buffer data
 964   1      //      delay_ms(200);
 965   1          BELL = 1;   
 966   1              LED1=1;
 967   1              LED2=1;
 968   1      
 969   1      
 970   1      draw_map();
 971   1      writedigital(22,4,65);
 972   1      writedigital(23,2,65);
 973   1      writedigital(16,4,57);
 974   1      writedigital(16,2,57);
 975   1      //writedigital(21,3,120);
 976   1      //writedigital(21,3,112);
 977   1      //writedigital(16,3,104);
 978   1      //writedigital(20,7,120);
 979   1      //writedigital(16,7,113);        
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 17  

 980   1      
 981   1      //draw_position(1,54);
 982   1      
 983   1      
 984   1      
 985   1      //      Adjust_res_18B20(0x3f);   //0.25
 986   1      //      ReadTemperature();
 987   1      
 988   1              
 989   1              Init_ADXL345();                 //初始化ADXL345
 990   1      //      devid=Single_Read_ADXL345(0X00);//读出的数据为0XE5,表示正确
 991   1      
 992   1              Init_HMC5883();
 993   1      //      InitITG3205();                   //初始化ITG3205
 994   1      
 995   1      
 996   1              TMOD = TMOD | 0x10;
 997   1              TH1=0x00;
 998   1              TL1=0x00;
 999   1              TF1=0;
1000   1              TR1=1;  
1001   1      
1002   1      
1003   1              TMOD = TMOD | 0x01;
1004   1              TH0=0x4c;
1005   1              TL0=0x00;
1006   1              TF0=0;
1007   1              TR0=1;                          
1008   1      
1009   1              TxBuf[1]=0xFF;
1010   1              TxBuf[3]=0xFF;                                                           
1011   1                      biaohao++;                                                                                                         //第一次数据
1012   1                      TxBuf[5]=biaohao;                       
1013   1                      LED1=~LED1;
1014   1      //              SendPacket(TxBuf,8,0);
1015   1                                              
1016   1      
1017   1                      my_send_data();
1018   1      
1019   1      
1020   1                      LED1=~LED1;
1021   1      //              writedigital(biaohao%10,7,92);
1022   1      //              Dispchar(biaohao%256,7,103);
1023   1                      tt=0;
1024   1      
1025   1      
1026   1              while(1)
1027   1              {                         
1028   2                if ((TH1*256+TL1)>=8558 || IMU_j>=1)    //时间应为10000us-573us，但本单片机晶振为11.0592MHz   //528是IMU耗
             -费时间，2857是步伐检测的时间
1029   2                {             if (KEY2!=0)                              //这样的话如果按着按键，惯导就不进行工作
1030   3                                      path_test();
1031   3                }
1032   2      
1033   2                 if (KEY1==0)
1034   2                 {
1035   3                 draw_position(position_x/100,position_y/100);         //这家伙耗时很多，大于100ms吧
1036   3                      }
1037   2      
1038   2      
1039   2                if(TF1==1)    {IMU_j++;TH1=0x00;TL1=0x00;TF1=0;}      
1040   2      
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 18  

1041   2                       if(TF0==1)
1042   2                       {      tt++;   
1043   3                              if(tt==20)                 //1s
1044   3                              {               
1045   4                                              biaohao++;
1046   4                                              TxBuf[5]=biaohao;                       
1047   4                                              LED1=~LED1;
1048   4                                              i_signal=i_signal+1;
1049   4                                              if(i_signal==2) 
1050   4                                              {/*     writeone(0,6,60);                 //清空                当
1051   5                                                      writeone(0,6,44);                       //                前
1052   5                                                      writeone(0,6,28);                         //            位
1053   5                                                      writeone(0,6,12);                               //                置
1054   5                                                      writeone(2,6,52);               //              无
1055   5                                                      writeone(3,6,36);                 //    信
1056   5                                                      writeone(4,6,20);                       //      号              */
1057   5                                                      i_signal=0;      
1058   5                                              }
1059   4                                              writedigital(angle,6,65);//为了省点时间，就在这显示了                                                                                                           
1060   4                                              my_send_data();
1061   4                                              path_num=0;             //周期内步伐数清零
1062   4                                              LED1=~LED1;
1063   4      //                                      Dispchar(biaohao%256,7,103);
1064   4                                              tt=0;                                   
1065   4                              }
1066   3                              TH0=0x4c;
1067   3                              TL0=0x00;
1068   3                              TF0=0;                                                                                   
1069   3                       }
1070   2                              
1071   2                      if(halRfReceivePacket(RxBuf,&leng))             
1072   2                      {       if (RxBuf[1]!=0xff)     
1073   3                              {               /*      writeone(0,6,52);               //              无         //清空
1074   4                                                      writeone(0,6,36);                 //    信
1075   4                                                      writeone(0,6,20);                       //      号      
1076   4                                                      writeone(5,6,60);                 //            当
1077   4                                                      writeone(6,6,44);                       //                前
1078   4                                                      writeone(7,6,28);                         //            位
1079   4                                                      writeone(8,6,12);                               //                置                               */
1080   4      
1081   4      //                       Dispchar(ss,3,30);                                       //测试，用来观察收到几个返回的数据包
1082   4      //                       if(RxBuf[5]==biaohao)                                                                                   //返回的第一个数据包，节点2345的RSSI  ，测试用
1083   4      //                       {      LED2=~LED2;
1084   4      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[3]),7,120);
1085   4      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[4]),5,120);
1086   4      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[6]),3,120);
1087   4      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[7]),1,120);
1088   4      //                              Dispchar(RxBuf[1],1,30);//附近最近节点。
1089   4                      //              Dispchar(RxBuf[3],7,120);
1090   4                      //              Dispchar(RxBuf[4],5,120);
1091   4                      //              Dispchar(RxBuf[6],3,120);
1092   4                      //              Dispchar(RxBuf[7],1,120);
1093   4      //                              writedigital(RxBuf[1],3,90);//附近最近节点。
1094   4      //                              ss++;
1095   4      //                              LED2=~LED2;
1096   4      //                       }
1097   4                               if(RxBuf[5]==biaohao)                                                                          //返回的第二个数据包。节点6789的RSSI ，测试用
1098   4                               {      LED2=~LED2;
1099   5      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[3]),7,80);
1100   5      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[4]),5,80);
1101   5      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[6]),3,80);
1102   5      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[7]),1,80);
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 19  

1103   5      //                              Dispchar(RxBuf[1],1,30);//附近最近节点。
1104   5                      //              Dispchar(RxBuf[3],7,90);
1105   5                      //              Dispchar(RxBuf[4],5,90);
1106   5                      //              Dispchar(RxBuf[6],3,90);
1107   5                      //              Dispchar(RxBuf[7],1,90);
1108   5                                      writedigital(RxBuf[1],3,90);//附近最近节点。
1109   5                                      Dispchar2(RxBuf[5]%100,5,100);
1110   5      //                              draw_position(RxBuf[3],RxBuf[6]);
1111   5      
1112   5      
1113   5                                      
1114   5      
1115   5                                      ss++;
1116   5                                      LED2=~LED2;
1117   5      
1118   5      
1119   5                                              biaohao++;
1120   5                                              TxBuf[5]=biaohao;                       
1121   5                                              LED1=~LED1;                                                
1122   5                                      Dispchar2(biaohao%100,7,103);
1123   5                                      my_send_data();
1124   5      
1125   5                                      LED1=~LED1;
1126   5                                      
1127   5                                              tt=0;                           
1128   5      
1129   5                               }
1130   4      /*                              if(RxBuf[5]==biaohao+2)                                                  //返回的第三个数据包，上位机发送的位置信息
1131   4                               {      LED2=~LED2;
1132   4      //                              Dispchar(RxBuf[3],3,40);
1133   4      //                              Dispchar(RxBuf[4],5,40);
1134   4      //                              Dispchar(RxBuf[6],3,40);
1135   4      //                              Dispchar(RxBuf[7],1,40);
1136   4      //                              Dispchar(RxBuf[1],1,40);//附近最近节点。
1137   4                      //              Dispchar(RxBuf[3],7,60);
1138   4                      //              Dispchar(RxBuf[4],5,60);
1139   4                      //              Dispchar(RxBuf[6],3,60);
1140   4                      //              Dispchar(RxBuf[7],1,60);
1141   4                      //              Dispchar(RxBuf[1],3,120);//附近最近节点。
1142   4                                      writedigital(RxBuf[1],3,90);
1143   4                                      ss++;
1144   4                                      LED2=~LED2;
1145   4      
1146   4      //                              draw_position()
1147   4      
1148   4      
1149   4      
1150   4                                              biaohao++;
1151   4                                              TxBuf[5]=biaohao;                       
1152   4                                              LED1=~LED1;
1153   4      //                                      SendPacket(TxBuf,8,0);
1154   4                                              {       TxBuf[4]=0x00;
1155   4                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
1156   4                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
1157   4                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
1158   4                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
1159   4                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
1160   4                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
1161   4                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
1162   4                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
1163   4                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
1164   4                                                      TxBuf[4]=0xFF;
C51 COMPILER V9.00   MAIN                                                                  06/05/2014 22:08:03 PAGE 20  

1165   4                                                      halRfSendPacket(TxBuf,6);       
1166   4                                              }
1167   4                                              LED1=~LED1;
1168   4      //              writedigital(biaohao%10,7,92);
1169   4                      Dispchar(biaohao%256,7,103);
1170   4                                              tt=0;                                   
1171   4      
1172   4      
1173   4                               } */
1174   4                               }
1175   3                               }
1176   2      
1177   2              }
1178   1              }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3492    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =    245    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     29      19
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
