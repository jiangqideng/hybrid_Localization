C51 COMPILER V9.00   MAIN                                                                  04/30/2014 09:53:23 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          #include <stdlib.h>
   4          #include "lcd12864a.h"
   5          #include "CC1101.h"
   6          #include "DS18B20.h"
   7          #include "IO_def.h"
   8          #include "server.h"
   9          
  10          //***************更多功率参数设置可详细参考DATACC1100英文文档中第48-49页的参数表******************
  11          //uchar PaTabel[8] = {0x04 ,0x04 ,0x04 ,0x04 ,0x04 ,0x04 ,0x04 ,0x04};  //-30dBm   功率最小
  12          //uchar PaTabel[8] = {0x60 ,0x60 ,0x60 ,0x60 ,0x60 ,0x60 ,0x60 ,0x60};  //0dBm
  13          xdata uchar PaTabel[8] = {0xC0 ,0xC0 ,0xC0 ,0xC0 ,0xC0 ,0xC0 ,0xC0 ,0xC0};   //10dBm     功率最大
  14          uchar RSSI;
  15          extern int j;
  16          /*int RSSI_to_RSSI_dB(uchar rssi)
  17          {       if(rssi>=128)
  18                          return (RSSI-255)/2-74;
  19                  else
  20                          return RSSI/2-74; 
  21           }      */
  22          
  23          void main()
  24          {               uchar i_signal=0;
  25   1                      uchar ten;
  26   1                      uchar xx=0,yy=0;
  27   1                      uchar ss=1;
  28   1      xdata   uchar leng=10;
  29   1      xdata   uchar tt=0;
  30   1      xdata   uchar TxBuf[6]={0};      // 8字节, 如果需要更长的数据包,请正确设置
  31   1      xdata   uchar RxBuf[8]={0};
  32   1      xdata   uchar biaohao=0;
  33   1          BELL =1;             //不响铃
  34   1              LED1=0;                  //开灯
  35   1              LED2=0;
  36   1      //      UART_init();
  37   1          back_lcd=0;           //液晶背光开
  38   1          lcd_init();
  39   1              delay1();
  40   1          delay1();
  41   1          delay1();
  42   1          disdate_a(0x00,0x00);
  43   1              delay1();
  44   1          delay1();
  45   1          delay1();
  46   1      //  entermenu();              /*-----开机显示  天津大学欢迎您！ -----*/
  47   1              delay1();
  48   1          delay1();
  49   1          delay1();
  50   1      //    disdate_a(0x00,0x00);
  51   1      //   back_lcd=1;                        //液晶背光关
  52   1      
  53   1              CpuInit();
  54   1              POWER_UP_RESET_CC1101();
  55   1              halRfWriteRfSettings();
C51 COMPILER V9.00   MAIN                                                                  04/30/2014 09:53:23 PAGE 2   

  56   1              halSpiWriteBurstReg(CC1101_PATABLE, PaTabel, 8);        // CC1101_PATABLE=0011 1111
  57   1              LED1=1;
  58   1              //TxBuf[0] = 8 ;
  59   1      //      TxBuf[1] = 1 ;
  60   1      //      TxBuf[2] = 1 ;
  61   1      //      halRfSendPacket(TxBuf,8);       // Transmit Tx buffer data
  62   1      //      delay_ms(200);
  63   1          BELL = 1;   
  64   1              LED1=1;
  65   1              LED2=1;
  66   1      
  67   1      draw_map();
  68   1      writedigital(22,4,65);
  69   1      writedigital(23,2,65);
  70   1      writedigital(16,4,57);
  71   1      writedigital(16,2,57);
  72   1      writedigital(21,3,120);
  73   1      writedigital(21,3,112);
  74   1      writedigital(16,3,104);
  75   1      writedigital(20,7,120);
  76   1      writedigital(16,7,113);
  77   1      
  78   1      draw_position(1,54);
  79   1      /*for (xx=1;xx<=77;xx++)
  80   1      { yy=1;
  81   1      draw_position(xx,yy);      delay_ms(100)        ;
  82   1      } 
  83   1      for (yy=1;yy<=56;yy++)
  84   1      { xx=77;
  85   1      draw_position(xx,yy);           delay_ms(100)   ;
  86   1      }
  87   1      for (xx=77;xx>=1;xx--)
  88   1      { yy=56;
  89   1      draw_position(xx,yy);      delay_ms(100)        ;
  90   1      } 
  91   1      for (yy=56;yy>=1;yy--)
  92   1      { xx=1;
  93   1      draw_position(xx,yy);  delay_ms(100)    ;
  94   1      }       */
  95   1      
  96   1              Init_DS18B20();
  97   1      //      Adjust_res_18B20(0x3f);   //0.25
  98   1      //      ReadTemperature();
  99   1      
 100   1      
 101   1              TMOD = TMOD | 0x10;
 102   1              TH1=0x3c;
 103   1              TL1=0xb0;
 104   1              TF1=0;
 105   1              TR1=1;
 106   1      
 107   1              TxBuf[1]=0xFF;
 108   1              TxBuf[3]=0xFF;                                                           
 109   1                      biaohao++;                                                                                                         //第一次数据
 110   1                      TxBuf[5]=biaohao;                       
 111   1                      LED1=~LED1;
 112   1      //              SendPacket(TxBuf,8,0);
 113   1                                              {       TxBuf[4]=0x00;
 114   2                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 115   2                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 116   2                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 117   2                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
C51 COMPILER V9.00   MAIN                                                                  04/30/2014 09:53:23 PAGE 3   

 118   2                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 119   2                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 120   2                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 121   2                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 122   2                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 123   2                                                      TxBuf[4]=0xFF;
 124   2                                                      halRfSendPacket(TxBuf,6);       delay_ms(6);
 125   2                                                      halRfSendPacket(TxBuf,6);       delay_ms(6);
 126   2                                                      halRfSendPacket(TxBuf,6);       delay_ms(6);
 127   2                                                      halRfSendPacket(TxBuf,6);       
 128   2                                              }
 129   1                      LED1=~LED1;
 130   1      //              writedigital(biaohao%10,7,92);
 131   1                      Dispchar(biaohao%256,7,103);
 132   1                      tt=0;
 133   1      
 134   1              while(1)
 135   1              {       
 136   2      
 137   2                      //ReadTemperature();
 138   2                      Init_DS18B20();
 139   2                      WriteOneChar_18B20(0xCC); // 跳过读序号列号的操作
 140   2                      WriteOneChar_18B20(0x44); // 启动温度
 141   2      
 142   2                                      //取温度
 143   2                      Init_DS18B20();
 144   2                      WriteOneChar_18B20(0xCC); //跳过读序号列号的操作
 145   2                      WriteOneChar_18B20(0xBE); //读取温度寄存器
 146   2                      
 147   2                      tempL=ReadOneChar_18B20(); //读出温度的低位LSB
 148   2                      tempH=ReadOneChar_18B20(); //读出温度的高位MSB 
 149   2                      
 150   2                      if(tempH>0x7f)      //最高位为1时温度是负
 151   2                      {
 152   3                      tempL=~tempL;         //补码转换，取反加一
 153   3                      tempH=~tempH+1;       
 154   3                      fg=0;      //读取温度为负时fg=0
 155   3                      }
 156   2                      integer = tempL/16+tempH*16;      //整数部分
 157   2                      decimal1 = (tempL&0x0f)*10/16; //小数第一位
 158   2                      decimal2 = (tempL&0x0f)*100/16%10;//小数第二位
 159   2                      decimal=decimal1*10+decimal2; //小数
 160   2      
 161   2                                      //显示温度
 162   2                      ten = integer/10;
 163   2                      writedigital(ten,1,120);          // 十位
 164   2                      ten = integer-ten*10;
 165   2                      writedigital(ten,1,112);          // 个位
 166   2                      writedigital(19,1,104);   // 小数点
 167   2                      ten = decimal/10;
 168   2                      writedigital(ten,1,101);          // 小数第一位
 169   2                      ten = decimal-ten*10;
 170   2      //              writedigital(ten,1,92);   // 小数第二位
 171   2                      writeone(1,1,85);         // ℃                         
 172   2      
 173   2      
 174   2                       if(TF1==1)
 175   2                       {      tt++;
 176   3                              if(tt==20)
 177   3                              {               biaohao++;
 178   4                                              TxBuf[5]=biaohao;                       
 179   4                                              LED1=~LED1;
C51 COMPILER V9.00   MAIN                                                                  04/30/2014 09:53:23 PAGE 4   

 180   4                                              i_signal=i_signal+1;
 181   4                                              if(i_signal==2) 
 182   4                                              {       writeone(0,6,60);                 //清空                当
 183   5                                                      writeone(0,6,44);                       //                前
 184   5                                                      writeone(0,6,28);                         //            位
 185   5                                                      writeone(0,6,12);                               //                置
 186   5                                                      writeone(2,6,52);               //              无
 187   5                                                      writeone(3,6,36);                 //    信
 188   5                                                      writeone(4,6,20);                       //      号      
 189   5                                                      i_signal=0;
 190   5                                              }
 191   4      //                                      SendPacket(TxBuf,8,0);
 192   4                                              {       TxBuf[4]=0x00;
 193   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 194   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 195   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 196   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 197   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 198   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 199   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 200   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 201   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(8);
 202   5                                                      TxBuf[4]=0xFF;
 203   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(6);
 204   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(6);
 205   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(6);
 206   5                                                      halRfSendPacket(TxBuf,6);       
 207   5                                              }
 208   4                                              LED1=~LED1;
 209   4      //              writedigital(biaohao%10,7,92);
 210   4                      Dispchar(biaohao%256,7,103);
 211   4                                              tt=0;                                   
 212   4                              }
 213   3                              TH1=0x3c;
 214   3                              TL1=0xb0;
 215   3                              TF1=0;                                                                                   
 216   3                       }
 217   2                              
 218   2                              
 219   2                              if(ReceivePacket(RxBuf,&leng))          
 220   2                              {                       writeone(0,6,52);               //              无         //清空
 221   3                                                      writeone(0,6,36);                 //    信
 222   3                                                      writeone(0,6,20);                       //      号      
 223   3                                                      writeone(5,6,60);                 //            当
 224   3                                                      writeone(6,6,44);                       //                前
 225   3                                                      writeone(7,6,28);                         //            位
 226   3                                                      writeone(8,6,12);                               //                置
 227   3      
 228   3      //                       Dispchar(ss,3,30);                                       //测试，用来观察收到几个返回的数据包
 229   3                               if(RxBuf[5]==biaohao)                                                                                   //返回的第一个数据包，节点2345的RSSI  ，测试用
 230   3                               {      LED2=~LED2;
 231   4      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[3]),7,120);
 232   4      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[4]),5,120);
 233   4      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[6]),3,120);
 234   4      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[7]),1,120);
 235   4      //                              Dispchar(RxBuf[1],1,30);//附近最近节点。
 236   4                      //              Dispchar(RxBuf[3],7,120);
 237   4                      //              Dispchar(RxBuf[4],5,120);
 238   4                      //              Dispchar(RxBuf[6],3,120);
 239   4                      //              Dispchar(RxBuf[7],1,120);
 240   4                                      writedigital(RxBuf[1],3,90);//附近最近节点。
 241   4                                      ss++;
C51 COMPILER V9.00   MAIN                                                                  04/30/2014 09:53:23 PAGE 5   

 242   4                                      LED2=~LED2;
 243   4                               }
 244   3                               if(RxBuf[5]==biaohao+1)                                                                                //返回的第二个数据包。节点6789的RSSI ，测试用
 245   3                               {      LED2=~LED2;
 246   4      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[3]),7,80);
 247   4      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[4]),5,80);
 248   4      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[6]),3,80);
 249   4      //                              Dispchar(RSSI_to_RSSI_dB(RxBuf[7]),1,80);
 250   4      //                              Dispchar(RxBuf[1],1,30);//附近最近节点。
 251   4                      //              Dispchar(RxBuf[3],7,90);
 252   4                      //              Dispchar(RxBuf[4],5,90);
 253   4                      //              Dispchar(RxBuf[6],3,90);
 254   4                      //              Dispchar(RxBuf[7],1,90);
 255   4                                      writedigital(RxBuf[1],3,90);//附近最近节点。
 256   4      
 257   4                                      draw_position(RxBuf[3],RxBuf[6]);
 258   4                                                      ten = RxBuf[3]/10;
 259   4                                                      writedigital(ten,4,50);   // 十位
 260   4                                                      ten = RxBuf[3]-ten*10;
 261   4                                                      writedigital(ten,4,42);   // 个位
 262   4                                                      writedigital(19,4,34);    // 小数点
 263   4                                                      ten = RxBuf[4]/10;
 264   4                                                      writedigital(ten,4,31);   // 小数第一位
 265   4                                                      ten = RxBuf[4]-ten*10;
 266   4                                                      writedigital(ten,4,22);   // 小数第二位
 267   4      
 268   4                                                      ten = RxBuf[6]/10;
 269   4                                                      writedigital(ten,2,50);   // 十位
 270   4                                                      ten = RxBuf[6]-ten*10;
 271   4                                                      writedigital(ten,2,42);   // 个位
 272   4                                                      writedigital(19,2,34);    // 小数点
 273   4                                                      ten = RxBuf[7]/10;
 274   4                                                      writedigital(ten,2,31);   // 小数第一位
 275   4                                                      ten = RxBuf[7]-ten*10;
 276   4                                                      writedigital(ten,2,22);   // 小数第二位
 277   4      
 278   4      
 279   4      
 280   4                                      ss++;
 281   4                                      LED2=~LED2;
 282   4      
 283   4      
 284   4                                              biaohao++;
 285   4                                              TxBuf[5]=biaohao;                       
 286   4                                              LED1=~LED1;
 287   4      //                                      SendPacket(TxBuf,8,0);
 288   4                                              {       TxBuf[4]=0x00;
 289   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 290   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 291   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 292   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 293   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 294   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 295   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 296   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 297   5                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 298   5                                                      TxBuf[4]=0xFF;
 299   5                                                      halRfSendPacket(TxBuf,6);       
 300   5                                              }
 301   4                                              LED1=~LED1;
 302   4                      //              writedigital(biaohao%10,7,92);
 303   4                                      Dispchar(biaohao%256,7,103);
C51 COMPILER V9.00   MAIN                                                                  04/30/2014 09:53:23 PAGE 6   

 304   4                                              tt=0;
 305   4      
 306   4                               }
 307   3      /*                              if(RxBuf[5]==biaohao+2)                                                  //返回的第三个数据包，上位机发送的位置信息
 308   3                               {      LED2=~LED2;
 309   3      //                              Dispchar(RxBuf[3],3,40);
 310   3      //                              Dispchar(RxBuf[4],5,40);
 311   3      //                              Dispchar(RxBuf[6],3,40);
 312   3      //                              Dispchar(RxBuf[7],1,40);
 313   3      //                              Dispchar(RxBuf[1],1,40);//附近最近节点。
 314   3                      //              Dispchar(RxBuf[3],7,60);
 315   3                      //              Dispchar(RxBuf[4],5,60);
 316   3                      //              Dispchar(RxBuf[6],3,60);
 317   3                      //              Dispchar(RxBuf[7],1,60);
 318   3                      //              Dispchar(RxBuf[1],3,120);//附近最近节点。
 319   3                                      writedigital(RxBuf[1],3,90);
 320   3                                      ss++;
 321   3                                      LED2=~LED2;
 322   3      
 323   3      //                              draw_position()
 324   3      
 325   3      
 326   3      
 327   3                                              biaohao++;
 328   3                                              TxBuf[5]=biaohao;                       
 329   3                                              LED1=~LED1;
 330   3      //                                      SendPacket(TxBuf,8,0);
 331   3                                              {       TxBuf[4]=0x00;
 332   3                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 333   3                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 334   3                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 335   3                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 336   3                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 337   3                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 338   3                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 339   3                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 340   3                                                      halRfSendPacket(TxBuf,6);       delay_ms(10);
 341   3                                                      TxBuf[4]=0xFF;
 342   3                                                      halRfSendPacket(TxBuf,6);       
 343   3                                              }
 344   3                                              LED1=~LED1;
 345   3      //              writedigital(biaohao%10,7,92);
 346   3                      Dispchar(biaohao%256,7,103);
 347   3                                              tt=0;                                   
 348   3      
 349   3      
 350   3                               } */
 351   3                               }
 352   2              }
 353   1              }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1692    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =      8      17
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
